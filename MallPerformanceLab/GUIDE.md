# Mall Performance Lab 学习指南

> 本指南旨在帮助开发者系统学习本项目，掌握 Android 性能优化的核心知识点。

---

## 一、项目概述

### 1.1 项目定位

Mall Performance Lab 是一个专注于 Android 性能优化的实战项目。它以电商首页为场景，完整实现了从数据获取到页面渲染的全链路优化方案。项目的最大特点是提供了 **Baseline（基线）** 和 **Optimized（优化）** 双版本对照，开发者可以直观地看到每种优化手段带来的实际效果提升。

这个项目非常适合以下人群：准备 Android 性能优化面试的开发者、希望系统学习性能优化知识的中高级工程师、以及需要在实际项目中落地性能优化的技术负责人。

### 1.2 核心特性

项目具备四个核心特性。第一是可观测性，所有优化都配有完整的性能打点，通过日志可以清晰看到每个环节的耗时。第二是可测量性，性能指标被量化记录，可以对比 Baseline 和 Optimized 模式的差异。第三是可切换性，运行时可以通过开关切换两种模式，方便进行对比验证。第四是可学习性，每个优化点都有对应的知识点文档，支持按需深入学习。

### 1.3 性能指标定义

项目定义了四个关键性能指标。冷启动时间（perf_mall_cold_start）指从应用启动到首帧渲染的时间，Baseline 目标为 500ms，Optimized 目标为 300ms。首屏数据时间（perf_mall_first_data）指从页面创建到首屏数据到达的时间，Optimized 模式通过缓存可控制在 100ms 以内。首屏渲染时间（perf_mall_first_content）指首屏所有元素渲染完成的时间，优化后可控制在 50-100ms。可交互时间（perf_mall_interactive）指首屏元素可以响应用户操作的时间，优化后可控制在 100-150ms。

---

## 二、学习路径建议

### 2.1 入门阶段（约 1-2 天）

入门阶段建议先通读 README.md 文件，了解项目的整体架构和目录结构。然后搭建开发环境，确保项目能够正常运行。接下来重点学习缓存策略相关代码，包括 MemoryCache.kt 和 DiskCache.kt，理解用空间换时间的基本思想。最后尝试运行项目，观察缓存命中前后的性能差异。

这个阶段的核心目标是理解性能优化的基本思维方式：找到耗时瓶颈、选择合适的优化策略、通过测量验证效果。

### 2.2 进阶阶段（约 2-3 天）

进阶阶段需要深入学习异步并发机制，理解 Kotlin 协程在性能优化中的应用。重点研究预创建策略（ViewPreWarmer.kt），这是高端面试中的常见问题。同时要掌握 RecyclerView 的优化技巧，包括 DiffUtil、ViewHolder 复用等。最后学习图片优化策略（BitmapProcessor.kt），理解内存优化的核心原理。

这个阶段的目标是能够独立分析性能问题，并选择合适的优化方案。

### 2.3 高阶阶段（约 3-5 天）

高阶阶段需要学习可观测性体系，理解 PerformanceTracker 的设计思想。研究预请求策略的整体架构，包括请求去重、延迟执行、Feed 预取等高级技巧。深入理解 FeatureToggle 的实现，能够设计类似的 AB 测试框架。最后阅读 KNOWLEDGE_MAP.md，建立完整的知识体系。

这个阶段的目标是能够从架构层面设计性能优化方案，并建立可落地的工程体系。

---

## 三、核心模块详解

### 3.1 性能打点系统

性能打点是整个项目的基石，它位于 core/perf/ 目录下，由 PerformanceTracker.kt 和 TraceLogger.kt 两个文件组成。PerformanceTracker 负责核心的性能数据采集，支持 begin/end 配对打点，能够自动计算耗时并生成统计报告。TraceLogger 负责结构化日志输出，使用方括号前缀（如 [CACHE]、[NETWORK]）方便在 Logcat 中筛选。

学习这个模块时，建议先阅读 PerformanceTracker.kt 的源码，理解以下几个关键设计：嵌套打点的支持允许在同一个打点周期内进行细粒度测量；模式分流机制将 Baseline 和 Optimized 的数据分别统计；自动汇总功能在页面结束时生成完整的性能报告。这些设计思想在实际项目中非常实用。

### 3.2 缓存策略体系

缓存策略是性能优化中最常用、效果最明显的手段。项目实现了三级缓存架构：内存缓存（MemoryCache.kt）使用 LruCache 实现，命中耗时小于 1ms；磁盘缓存（DiskCache.kt）使用 SharedPreferences 实现，命中耗时小于 10ms；网络缓存则需要 300-1500ms。三级缓存的查询顺序是内存优先，然后是磁盘，最后才是网络。

学习缓存策略时，需要重点关注以下几个问题：TTL（Time To Live）过期机制如何设计、LruCache 的容量如何确定、多级缓存的一致性如何保证。项目中 TTL 的设计是：首页数据 5 分钟、Feed 数据 2 分钟、配置数据 30 分钟。这个设计背后的逻辑是不同类型数据的更新频率不同，需要设置不同的过期时间。

### 3.3 预创建策略

预创建策略的核心思想是把耗时操作提前执行，移出用户可感知的等待时间。ViewPreWarmer.kt 在 Application 启动时就开始预创建首屏需要的 View，包括 BannerFloor、CouponFloor、GridFloor 和 ProductFeed 四种类型。预创建完成后，这些 View 会被放入池中管理，使用时直接从池中获取。

预创建策略的关键实现细节包括：acquire/release 模式的池化复用机制、状态重置防止数据污染、ViewType 分类管理。在面试中回答预创建相关问题时，应该突出以下几点：预创建的时机选择（启动期间、后台线程）、预创建的内存代价与性能收益权衡、以及如何避免预创建的资源浪费。

### 3.4 预请求策略

预请求策略的目标是让用户进入页面时数据已经就绪。PreFetcher.kt 实现了完整的预请求机制：用户进入页面之前 500ms 开始触发预请求，这个延迟时间是为了避免和启动期的其他网络请求争抢带宽；使用 ConcurrentHashMap 实现请求去重，相同 key 的请求只发一次；Feed 列表在剩余 3 条时自动预取下一页。

预请求策略需要处理几个关键问题：请求优先级的确定（首屏数据优先于次屏数据）、预取数据的有效期管理、以及带宽感知调度（WiFi 环境下可以预取更多数据）。这些问题的解决方案在生产环境中非常重要。

### 3.5 RecyclerView 优化

RecyclerView 的优化是 Android 开发中最常见的性能优化场景。项目在 core/ui/RecyclerViewOptimizer.kt 中实现了多种优化手段：Prefetch 机制提前加载即将进入屏幕的 item、setItemViewCacheSize 扩大缓存容量、DiffUtil 实现增量更新避免全量刷新。

学习 RecyclerView 优化时，建议按照以下顺序阅读源码：首先理解 ViewHolder 的复用机制，这是 RecyclerView 高性能的基础；然后学习 DiffUtil 的实现原理，理解如何比较两个列表的差异；最后研究 Prefetch 的工作机制，理解 Android 系统如何预测用户的滚动行为。

---

## 四、实践练习

### 4.1 练习一：观察缓存效果

第一步是清除应用缓存，可以通过点击界面上的「清空」按钮实现。第二步切换到 Baseline 模式，记录冷启动时的性能数据，观察日志中 [CACHE_MISS] 的输出。第三步再次进入页面，切换到 Optimized 模式，观察 [CACHE_HIT] 的输出和性能数据的改善。通过这个练习，可以直观感受到缓存带来的性能提升。

建议记录的数据包括：首次进入的首屏数据时间、二次进入的首屏数据时间、以及两者的差值。理想情况下，二次进入的首屏数据时间应该在 100ms 以内。

### 4.2 练习二：添加新的打点

在 MallRepository.kt 中添加一个新的打点，记录数据从仓库到 UI 的传递时间。首先需要了解 PerformanceTracker 的 API：begin() 方法接收一个 tag 作为标识，end() 方法结束打点并计算耗时。添加完打点后，运行项目观察新的打点数据是否正常输出。

这个练习的目的是理解性能打点的实现原理，并掌握在项目中添加自定义打点的能力。这是性能优化的基础技能。

### 4.3 练习三：实现新的缓存策略

在 core/cache/ 目录下实现一个简单的缓存装饰器，为现有缓存添加压缩功能。这个练习需要理解装饰器模式在 Kotlin 中的实现方式，以及压缩算法对性能的影响。实现完成后，对比添加压缩前后的缓存读写性能。

这个练习的难度较高，建议在完成前两个练习后再进行。

### 4.4 练习四：对比 Baseline 和 Optimized

使用 Android Studio 的 Profiler 工具，分别在 Baseline 和 Optimized 模式下进行性能分析。对比 CPU 使用率、内存占用、帧率等指标的差异，并尝试解释差异产生的原因。这个练习能够培养使用专业工具进行性能分析的能力。

---

## 五、面试相关

### 5.1 高频面试题

以下是项目相关的常见面试题。问题一：请介绍你做过的性能优化项目。回答模板是：首先描述项目背景（电商首页，首屏加载慢），然后说明性能目标（首屏时间从 2s 优化到 500ms），接着介绍采取的措施（缓存、预创建、异步化），最后说明验证结果（通过打点数据证明效果）。

问题二：如何设计一个缓存系统？回答要点包括：多级缓存架构设计（内存+磁盘）、LRU 淘汰策略、TTL 过期机制、以及缓存穿透/击穿/雪崩的处理方案。可以结合 MemoryCache.kt 和 DiskCache.kt 的实现来回答。

问题三：预创建有什么缺点？如何避免？预创建的缺点包括增加启动时间、增加内存占用、以及可能创建用户不会使用的资源。避免方法是根据用户行为数据确定预创建范围、设置合理的预创建数量上限、以及在内存紧张时主动释放预创建的资源。

### 5.2 项目亮点阐述

在面试中介绍这个项目时，可以强调以下几个亮点。第一是双版本对照的设计，所有优化都有 Baseline 作为参照，能够清晰证明优化效果。第二是完整的可观测性体系，从打点到日志再到报告，形成了闭环。第三是架构的可扩展性，新增优化项只需实现相应接口即可融入体系。第四是实战导向，所有优化都是实际项目中会遇到的场景。

### 5.3 延伸知识储备

学习本项目后，建议继续深入学习以下内容：Systrace 和 Perfetto 的使用方法、Android Profiler 的高级功能、Kotlin Flow 在性能优化中的应用、以及 Compose 时代的性能优化策略。这些知识能够帮助你在面试中展现更全面的技术视野。

---

## 六、调试技巧

### 6.1 查看性能日志

使用 adb 命令过滤项目日志：`adb logcat -s MallPerfLab`。日志会按照前缀分类：[CACHE] 缓存相关、[NETWORK] 网络相关、[PERF] 性能打点、[PREFETCH] 预请求、[PREWARM] 预创建。通过分类前缀可以快速定位到感兴趣的信息。

### 6.2 使用系统工具

查看内存使用情况：`adb shell dumpsys meminfo com.mall.perflab`。观察 FPS：`adb shell dumpsys gfxinfo com.mall.perflab`。这些系统工具能够提供更详细的性能数据。

### 6.3 性能报告输出

点击界面上的「报告」按钮，可以输出完整的性能打点报告。报告中包含所有打点的统计数据，包括调用次数、平均耗时、最大耗时、最小耗时等。对比 Baseline 和 Optimized 模式的报告，可以量化每个优化的效果。

---

## 七、学习资源

### 7.1 项目内文档

本项目的文档体系包括：README.md 提供快速入门和架构概览、PERFORMANCE_PRINCIPLES.md 讲解优化原理与思路、KNOWLEDGE_MAP.md 建立知识体系、SPEECH_2MIN.md 准备面试讲稿。建议按照这个顺序阅读。

### 7.2 延伸阅读

推荐阅读 Android 官方文档中的性能优化章节、Google I/O 关于性能优化的演讲、以及 Android Dev Summit 中与性能相关的最佳实践。这些资源能够帮助理解 Google 推荐的性能优化方法论。

---

## 八、常见问题

### 8.1 项目无法编译

检查 Android Studio 版本是否为 2021.3 或更高版本，Gradle 版本是否为 7.4 或更高，JDK 版本是否为 11 或 17。确保网络连接正常，能够下载依赖包。

### 8.2 性能数据不准确

性能打点数据可能因为调试模式而不准确，建议在 Release 模式下进行性能测试。另外，首次进入页面的数据会受系统预热影响，建议进行多次测试取平均值。

### 8.3 如何添加新的优化项

添加新的优化项需要以下步骤：在 core/ 目录下创建新的模块、实现相应的优化逻辑、在 FeatureToggle.kt 中添加开关控制、在文档中记录优化原理和预期效果。这种模块化的设计使得项目具有良好的可扩展性。

---

**文档版本**：1.0.0
**最后更新**：2024 年
