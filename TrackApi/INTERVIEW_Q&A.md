# 面试追问清单 - Observability Mini-Kit

## 基础问题

### Q1: 为什么采用多模块设计（:app + :observability）？

**答题要点**：
- 监控框架应该是**可插拔、可复用**的
- 未来可以打包成 AAR 发布到内部 Maven 仓库
- 团队中多个项目可以共享同一套监控能力
- 避免监控代码与业务代码耦合

**Trade-off**：增加了一点多模块配置复杂度，但换来了复用性

---

### Q2: Facade 模式在这里的作用是什么？

**答题要点**：
- 封装复杂子系统，提供统一接口
- 降低业务方使用门槛：`Observability.logEvent()`
- 便于后续统一添加公共逻辑（如统一加 Tag）
- 面试官可能追问：单例 vs 依赖注入 → 生产环境推荐注入

---

### Q3: TrackerRegistry 用的是什么数据结构？为什么？

**答题要点**：
- `CopyOnWriteArrayList` - 线程安全的 ArrayList
- 读多写少场景下性能优秀
- 注册/注销Tracker操作不频繁
- 遍历分发时不需要锁

**追问**：和 `synchronized` 相比？→ 无锁读，性能更好

---

### Q4: 采样算法是怎么实现的？

**答题要点**：
- `Random.nextFloat() < rate` - 简单高效
- 默认采样率 1.0（全部）
- 支持按类型单独配置

**追问**：随机采样有什么问题？→ 同一用户可能采样不一致
**进阶**：可用 `hash(userId, eventType) % 100 < rate`

---

### Q5: FallbackHandler 的设计目的是什么？

**答题要点**：
- **监控代码本身不能影响业务**
- catch 所有异常，吞掉并记录
- 体现「监控不能成为业务的问题」这一底线思维

**Trade-off**：异常被吞掉可能导致监控失效，需要额外的「监控的监控」

---

## 进阶问题

### Q6: 性能追踪的 start/stop 模式有什么好处？

**答题要点**：
- 自动计算耗时，无需手动记录时间戳
- 支持闭包形式，更优雅
- 可扩展：后续可以添加阈值告警

**追问**：如果忘记 stop 怎么办？→ ConcurrentHashMap 会内存泄漏
**进阶**：可以用 WeakReference 或超时机制

---

### Q7: 降级开关是怎么实现的？

**答题要点**：
- `FeatureSwitch.isEnabled(feature)` - 简单的 Map 查询
- 支持动态配置（模拟远端配置）
- 默认全部开启

**追问**：配置生效有延迟怎么办？→ 定时轮询或长连接推送

---

### Q8: 线程安全是怎么保证的？

**答题要点**：
- `CopyOnWriteArrayList` - Tracker 列表
- `ConcurrentHashMap` - 性能追踪记录
- `Volatile` - 配置变量

**追问**：为什么不用 `synchronized`？→ 锁粒度问题，读操作不需要阻塞

---

### Q9: 如何保证监控代码本身的性能？

**答题要点**：
- 采样控制数据量
- 异步上报（可扩展）
- 尽量减少对象创建
- inline 函数减少 lambda 开销

**量化指标**：通常监控开销 < 1ms/次

---

### Q10: StructuredLogger 的设计有什么考量？

**答题要点**：
- JSON 格式便于日志收集系统解析
- 对接 ELK、Grafana 等工具
- 保留 message 字段便于人眼阅读

**追问**：JSON 序列化有性能开销怎么办？→ 可配置开关，或批量序列化

---

## 生产级问题

### Q11: 如果要在生产环境使用，还需要加什么？

**答题要点**：
1. **上报系统**：对接 Logcat → Kafka → Flink
2. **配置中心**：Apollo / Mconfig 动态配置
3. **ANR 监控**：FileObserver + 堆栈收集
4. **卡顿检测**：Looper 消息插桩
5. **APM 集成**：Sigar / Perfetto

---

### Q12: 如何处理高并发场景？

**答题要点**：
- 采样降级减少数据量
- 批量上报减少 IO 次数
- 异步队列缓冲
- 限流熔断机制

**追问**：数据积压怎么办？→ 磁盘落盘 + 渐进式上报

---

### Q13: 如何保证数据完整性？

**答题要点**：
- APP 崩溃时数据丢失 → 使用 MMKV/SharedPreferences 暂存
- 下次启动时补报
- 序列号机制去重

---

### Q14: 异常堆栈如何有效收集？

**答题要点**：
- 限制堆栈行数（避免过长日志）
- 敏感信息脱敏
- 按异常类型分级（Fatal / Error / Warn）

---

### Q15: 如何设计一个完整的 APM 系统？

**答题要点**：
1. **数据采集**：方法耗时、网络请求、页面加载
2. **数据传输**：压缩 + 批量 + 加密
3. **数据存储**：本地缓存 + 渐进式上报
4. **数据分析**：聚合统计 + 异常检测
5. **告警通知**：阈值告警 + 异常告警

---

## Kotlin 特性相关

### Q16: 为什么用 `data class`？有什么坑？

**答题要点**：
- 自动生成 `equals/hashCode/toString`
- 解构方便
- 坑：继承问题（data class 不能被继承）

---

### Q17: `inline` 函数的作用？

**答题要点**：
- 消除 lambda 带来的额外类开销
- 适合高频调用的小函数
- `noinline` 保留参数为对象

---

### Q18: `sealed class` 和 `enum class` 的区别？

**答题要点**：
- sealed class：子类可以带不同数据
- enum class：所有实例是单例
- 监控场景常用 sealed class 表示不同事件类型

---

## 场景题

### Q19: 线上发现某个接口慢，如何定位？

**答题要点**：
1. 查看 APM 监控，确定慢的接口和比例
2. 查看 P50/P90/P99 分位数
3. 关联用户特征（机型、网络、地域）
4. 缩小范围后，在测试环境复现
5. 使用 Profile 工具定位具体方法

---

### Q20: 线上 Crash 率突然上升，如何快速止血？

**答题要点**：
1. 确认影响的版本和用户范围
2. 分析堆栈，找到共性问题
3. 如果是代码问题：
   - 热修复（Robust/Tinker）
   - 降级开关关闭有问题功能
4. 如果是配置问题：
   - 配置回滚
   - 动态降级
5. 完善测试用例，防止复发

---

## 答题技巧

1. **先讲结论**：直接回答问题
2. **再讲原理**：为什么这样设计
3. **最后讲 Trade-off**：有什么缺点、改进空间
4. **结合场景**：联系实际项目经验
5. **适当延伸**：如果是你，你会怎么做
