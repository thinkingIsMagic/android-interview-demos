# 核心知识点速查

## 1. 设计模式

### Facade（外观）模式
**定义**：为子系统中的一组接口提供一个统一的接口
**在本项目中的应用**：`Observability` 单例作为统一入口
**优点**：
- 降低使用复杂度
- 便于统一管理
- 解耦业务与实现细节

### Registry（注册表）模式
**定义**：通过中心化管理一组可注册/注销的对象
**在本项目中的应用**：`TrackerRegistry` 管理所有 Tracker
**优点**：
- 支持动态扩展
- 集中管理，易于维护
- 符合开闭原则

### Strategy（策略）模式
**定义**：定义一系列算法，将它们封装起来，使它们可互换
**在本项目中的应用**：采样策略、降级策略可替换
**优点**：
- 算法可灵活切换
- 易于扩展新策略
- 消除条件语句

## 2. 线程安全

### CopyOnWriteArrayList
**适用场景**：读多写少的集合操作
**原理**：写操作时复制整个数组，读操作无锁
**优点**：遍历时不需要加锁
**缺点**：
- 写操作开销大
- 内存占用高
- 不适合频繁写入

### ConcurrentHashMap
**适用场景**：高并发读写
**原理**：分段锁（早期）或 CAS（新版）
**优点**：
- 并发度高
- 锁粒度细
- 适合大量读写

### Volatile
**作用**：
- 保证可见性（一个线程修改，其他线程立即可见）
- 禁止指令重排序
**不保证**：原子性（i++ 仍需 synchronized）

## 3. Kotlin 特性

### data class
**自动生成**：
- `equals()` / `hashCode()`
- `toString()`
- `copy()`
- `componentN()` 解构

**限制**：
- 只能实现接口，不能继承
- 至少有一个参数

### inline 函数
**作用**：
- 消除 lambda 对象的额外开销
- 允许非局部返回

**注意**：
- 只适合高频调用的小函数
- 过度使用会增加 APK 大小

### by lazy
**作用**：延迟初始化
**线程安全**：
- `lazy()` 默认线程安全
- `lazy(LazyThreadSafetyMode.NONE)` 不同步

### sealed class
**特点**：
- 有限子类
- 模式匹配完整
- 子类可带不同数据

## 4. 性能优化

### 采样策略
**目的**：控制数据量，降低服务端压力
**算法**：
- 随机采样：`random < rate`
- 哈希采样：`hash(uid) % 100 < rate`

**注意事项**：
- 采样率要平衡数据量和性能
- 关键事件可以提高采样率

### 降级策略
**目的**：当监控本身影响性能时快速关闭
**设计要点**：
- 配置下发要及时
- 默认值要保守
- 有完善的监控

### 批量上报
**目的**：减少网络请求次数
**实现方式**：
- 内存队列缓冲
- 定时批量上报
- 达到阈值立即上报

## 5. 可观测性三大支柱

### Metrics（指标）
**定义**：可聚合的数值
**示例**：
- 接口响应时间 P50/P90/P99
- Crash 率
- ANR 率

### Logs（日志）
**定义**：离散的事件记录
**特点**：
- 详细但不可聚合
- 便于问题定位

### Traces（链路）
**定义**：请求在分布式系统中的流转路径
**示例**：
- 端到端请求耗时
- 方法调用链

## 6. Android 性能监控

### 卡顿检测
**原理**：Looper 消息插桩
**实现**：
- 设置 Printer 监听 `dispatchMessage` 前后
- 超过阈值判定为卡顿

### ANR 监控
**原理**：FileObserver 监听 /data/anr/traces.txt
**流程**：
1. 监听文件变化
2. 读取文件内容
3. 解析堆栈信息
4. 上报分析

### 网络监控
**原理**：OkHttp Interceptor 或网络层 hook
**采集数据**：
- 请求 URL
- 响应状态码
- 请求耗时
- 请求/响应大小

## 7. 常见面试问题

### Q: 监控代码本身不能影响业务，怎么理解？

**A**: 监控代码应该：
- 性能开销极低（< 1ms）
- 有完善的 Fallback 机制
- 即使监控崩溃，业务照常运行

### Q: 线上数据量太大怎么办？

**A**:
- 采样控制数据量
- 批量上报减少请求
- 异步上报不阻塞业务
- 磁盘落盘防丢失

### Q: 如何设计一个 APM？

**A**:
1. 采集层：方法耗时、网络、ANR、卡顿
2. 传输层：压缩、加密、批量
3. 存储层：本地缓存 + 渐进上报
4. 分析层：聚合统计 + 异常检测
5. 展示层：Dashboard + 告警

## 参考资料

- [Android 性能优化](https://developer.android.com/topic/performance)
- [Kotlin 协程](https://kotlinlang.org/docs/coroutines-overview.html)
- [Android APM 实践](https://tech.meituan.com/2018/10/11/meituan-apm-practice.html)
